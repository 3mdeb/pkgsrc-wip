#!@RCD_SCRIPTS_SHELL@
#
# PROVIDE: gnunet
# REQUIRE: DAEMON NETWORKING
# KEYWORD: shutdown
#
# You will need to set some variables in /etc/rc.conf to start gnunet:
#
# gnunet=YES

if [ -f /etc/rc.subr ]
then
	. /etc/rc.subr
fi

name="gnunet"
rcvar=$name
command="@PREFIX@/bin/gnunet-arm"
required_files="@PKG_SYSCONFDIR@/gnunet.conf"
pidfile="@PKG_HOME@/${name}.pid"
: ${gnunet_user:=@GNUNET_USER@}
: ${gnunet_group:=@GNUNET_GROUP@}
: ${gnunet_home:=@PKG_HOME@}
: ${gnunetdns_group:=@GNUNETDNS_GROUP@}

extra_commands="reload"
start_cmd="gnunet_start"
start_precmd="gnunet_precmd"
stop_cmd="gnunet_stop"
restart_cmd="gnunet_stop ; gnunet_start"
restart_precmd="gnunet_precmd"
reload_cmd="gnunet_reload"

gnunet_chdir="${gnunet_home}"
gnunet_env="HOME=${gnunet_home}"
gnunet_env="${gnunet_env} USER=${gnunet_user}"

gnunet_precmd()
{
	if [ -n "$(find @PKG_HOME@/.local/share/gnunet -maxdepth 1 -name gnunet.conf -perm 0044)" ]; then
		warn "@PKG_HOME@/.local/share/gnunet/gnunet.conf"
		warn "must not be world or group readable, use"
		warn "chmod 600" 
		warn "and chown @GNUNET_USER@:@GNUNET_GROUP@"
		return 1
	fi
	if [ ! -d ${gnunet_home}/.cache/gnunet ]; then
		mkdir -p ${gnunet_home}/.cache/gnunet
	fi
	if [ ! -f ${required_files} ]; then
		warn "${required_files} does not exist."
		return 1
	fi
}

gnunet_start()
{
	@ECHO@ "Starting ${name}."
	doit="@SU@ -m ${gnunet_user} -c '${command} ${command_args} -s -c @PKG_SYSCONFDIR@/gnunet.conf'"
	eval $doit
}

gnunet_stop()
{
	@ECHO@ "Stopping ${name}."
	doit="@SU@ -m ${gnunet_user} -c '${command} ${command_args} -e -c @PKG_SYSCONFDIR@/gnunet.conf'"
	kill `cat ${pidfile}` 2>/dev/null
	sleep 1
	rm -rf /tmp/gnunet-gnunet-runtime 2>/dev/null 2>&1
	rm -rf /tmp/gnunet-system-runtime 2>/dev/null 2>&1
}

if [ -f /etc/rc.subr -a -f /etc/rc.conf -a -d /etc/rc.d -a -f /etc/rc.d/DAEMON ]; then
	load_rc_config $name
	run_rc_command "$1"
else
	pidfile="${gnunet_home}/${name}.pid"
	case "$1" in
	restart)
		eval ${restart_precmd}
		eval ${restart_cmd}
		;;
	stop)
		if [ -r "${pidfile}" ]; then
			eval ${stop_cmd}
		fi
		;;
	reload)
		eval ${reload_cmd}
		;;
	*)
		eval ${start_precmd}
		eval ${start_cmd}
		;;
	esac
fi

$NetBSD$

Merge from https://raw.githubusercontent.com/wavexx/fgallery/master/fgallery
Use a "cmd_exists" for tests of existence of commands in given environment
Use oct instead of 0### and don't return undef explicitely (Perl::Critic)
Adaptions for keeping all fgallery files in view subdirectory
Pretty print json for easier customization

--- fgallery.orig	2016-05-25 09:53:19.000000000 +0000
+++ fgallery
@@ -8,6 +8,8 @@ use warnings;
 
 use locale;
 use utf8;
+use if $^V lt v5.23.4, open => qw{:std :utf8};
+use if $^V ge v5.23.4, open => qw{:std :locale};
 require Encode;
 require encoding;
 
@@ -20,25 +22,20 @@ use Fcntl;
 use File::Basename qw{fileparse};
 use File::Find qw{find};
 use File::Path qw{make_path remove_tree};
-use File::Spec::Functions qw{rel2abs};
-use FindBin qw{$RealBin};
+use File::Spec::Functions qw{rel2abs canonpath catfile};
 use Getopt::Long qw{:config bundling};
 use IO::Handle;
 use Image::ExifTool qw{ImageInfo};
 use Time::Piece;
 
-# We require either Cpanel::JSON::XS or JSON::PP (JSON::XS does not support ithreads)
-my $JSON_cls = eval { require Cpanel::JSON::XS; "Cpanel::JSON::XS"; } //
-	       eval { require JSON::PP; "JSON::PP"; } //
-	       fatal("either Cpanel::JSON::XS or JSON::PP is required");
-$JSON_cls->import(qw{encode_json});
+use JSON::PP;
 
 # constants
 our $VERSION = "1.8.2";
 our $ENCODING = encoding::_get_locale_encoding() || 'UTF-8';
 
 # defaults
-my $mode = 0644;
+my $mode = oct(644);
 my $slim = 0;
 my $ofile = 0;
 my $orient = 1;
@@ -55,6 +52,7 @@ my $fullpano = 1;
 my $nodown = 0;
 my $panort = 2.;
 my $facedet = 0;
+my $keeporig = 0;
 my $jpegoptim = 1;
 my $pngoptim = 1;
 my $p7zip = 1;
@@ -63,6 +61,7 @@ my $workers = 0;
 my $sRGB = 1;
 my $indexUrl = undef;
 my @capmethods = ("txt", "xmp", "exif");
+my $use_symlinks = 0;
 
 
 # support functions
@@ -73,6 +72,14 @@ sub fatal
 }
 
 
+# see if our environment has a given command installed
+sub cmd_exists
+{
+  my ($c) = @_;
+  return qx{/bin/sh -c "command -v $c"};
+}
+
+
 sub sys
 {
   my @cmd = @_;
@@ -87,13 +94,13 @@ sub sys
   }
 
   local $/ = undef;
-  my $out = <$fd>;
+  my $output = <$fd>;
 
   unless(close($fd)) {
     fatal("command \"@cmd\" failed");
   }
 
-  return split("\n", $out);
+  return split("\n", $output);
 }
 
 
@@ -110,7 +117,10 @@ sub isin
 sub slurp
 {
   my ($fn) = @_;
-  open(my $fd, "<:encoding($ENCODING)", "$fn") or fatal("cannot read $fn: $!");
+  open(my $fd, '<', $fn) or fatal("cannot read $fn: $!");
+  if($^V lt v5.23.4) {
+    binmode($fd, ":encoding($ENCODING)");
+  }
   local $/;
   return <$fd> // "";
 }
@@ -154,7 +164,7 @@ sub par_map
 
   dispatch(sub
   {
-    my $i = shift;
+    my ($i) = @_;
     my $r = &$fun($seq[$i]);
     $res[$i] = defined($r)? freeze($r): undef;
   },
@@ -263,7 +273,7 @@ sub cap_clean_desc
 sub cap_from_str
 {
   my ($title, $desc) = split("\n", shift, 2);
-  return undef if(!$title && !$desc);
+  return unless $title || $desc;
   my $ret = [cap_clean_title($title), ($desc? cap_clean_desc($desc): '')];
   return $ret;
 }
@@ -322,7 +332,7 @@ sub parse_cap
 
 sub print_version
 {
-  print("fgallery $VERSION\n");
+  print("$0 $VERSION\n");
   exit(0);
 }
 
@@ -336,6 +346,7 @@ sub print_help
   -i			include individual originals
   -c methods		caption extraction methods (txt,xmp,exif,cmt or none)
   -o			do not auto-orient
+  -k			do not modify files, keep original
   -t			do not time-sort
   -r			reverse album order
   -p			do not automatically include full-sized panoramas
@@ -348,6 +359,7 @@ sub print_help
   --no-sRGB		do not remap preview/thumbnail color profiles to sRGB
   --quality Q		preview image quality (0-100, currently: $imgq)
   --index url		specify the URL location for the index/back button
+  --use-symlinks        symlink instead of copying %%FG_VIEWDIR%%
 });
   exit(shift);
 }
@@ -363,6 +375,7 @@ my ($ret, @ARGS) = GetOptions(
   'i' => sub { $ofile = 1; },
   'j=i' => sub { $workers = parse_int($_[0], $_[1], 1, undef); },
   'o' => sub { $orient = 0; },
+  'k' => sub { $keeporig = 1; },
   'p' => sub { $fullpano = 0; },
   'r' => sub { $revsort = 1; },
   's' => sub { $slim = 1; },
@@ -373,7 +386,9 @@ my ($ret, @ARGS) = GetOptions(
   'min-thumb=s' => sub { @minthumb = parse_wh(@_); },
   'no-sRGB' => sub { $sRGB = 0; },
   'quality=i' => sub { $imgq = parse_int($_[0], $_[1], 0, 100); },
-  'index=s' => sub { $indexUrl = decode($_[1]); });
+  'index=s' => sub { $indexUrl = decode($_[1]); },
+  'use-symlinks' => sub { $use_symlinks = 1; },
+);
 
 if(@ARGV < 2 || @ARGV > 3 || !$ret) {
   print_help(2);
@@ -383,8 +398,16 @@ my $out = $ARGV[1];
 my $name = (@ARGV < 3? undef: decode($ARGV[2]));
 
 # check paths
-my $absDir = rel2abs($dir) . '/';
-my $absOut = rel2abs($out) . '/';
+my $absDir = canonpath(rel2abs($dir));
+my $absOut = canonpath(rel2abs($out));
+
+sub is_fgallery_dir
+{
+    return unless -d catfile($out, 'view');
+    return unless -e catfile($out, 'index.html');
+    return unless -e catfile($out, 'data.json');
+    return 1;
+}
 
 if(!-d $dir) {
   fatal("input directory \"$dir\" does not exist");
@@ -393,55 +416,37 @@ if(!-d $dir) {
 } elsif(substr($absOut, 0, length($absDir)) eq $absDir) {
   fatal("output directory is a sub-directory of input, refusing to scan");
 } elsif(!-d $out) {
-  sys('cp', '-L', '-R', "$RealBin/view", $out);
-} elsif(!-f "$out/index.html") {
-  fatal("output directory already exists, but doesn't look like a template copy");
+  mkdir($out);
+  unless ($use_symlinks) {
+      sys('cp', '-L', '-R', '%%FG_VIEWDIR%%', $out);
+      sys('mv', '%%FG_VIEWDIR%%/index.html', $out);
+  }
+} elsif(!is_fgallery_dir) {
+  fatal("output directory exists, but doesn't look like a fgallery template");
 }
 
 # check tools
-if(system("identify -version >/dev/null 2>&1")
-|| system("convert -version >/dev/null 2>&1")) {
-  fatal("cannot run \"identify\" or \"convert\" (check if ImageMagick is installed)");
-}
-if(system("7za -h >/dev/null 2>&1"))
-{
+fatal 'Missing identify or convert executable (from ImageMagick)'
+  unless cmd_exists('identify') || cmd_exists('convert');
+unless(cmd_exists('7za')) {
   $p7zip = 0;
-  if(system("zip -h >/dev/null 2>&1")) {
-    fatal("cannot run \"zip\" (check if 7za or zip is installed)");
-  }
-}
-if(system("jpegoptim -V >/dev/null 2>&1")) {
-  $jpegoptim = 0;
-}
-if(system("pngcrush -h >/dev/null 2>&1")) {
-  $pngoptim = 0;
-}
-if($facedet && system("facedetect -h >/dev/null 2>&1")) {
-  fatal("cannot run \"facedetect\" (see https://www.thregr.org/~wavexx/software/facedetect/)");
-}
-
-my $tificccmd;
-if($sRGB)
-{
-  if(!system("tificc >/dev/null 2>&1")) {
-    $tificccmd = "tificc";
-  } elsif(!system("tificc2 >/dev/null 2>&1")) {
-    $tificccmd = "tificc2";
-  } else {
-    fatal("cannot run \"tificc\" or \"tificc2\" (check if liblcms2-utils is installed)");
-  }
+  cmd_exists('zip') || fatal('Missing 7z or zip command');
 }
-
+$jpegoptim = 0 unless cmd_exists('jpegoptim');
+$pngoptim = 0 unless cmd_exists('pngcrush');
+fatal 'Missing facedetect (see http://www.thregr.org/~wavexx/hacks/facedetect/'
+  if $facedet && !cmd_exists('facedetect');
+fatal 'Missing tificc executable (from lcms2 library)'
+  if $sRGB && !cmd_exists('tificc');
+my $tificccmd = 'tificc';
 my $exiftrancmd;
-if($orient)
+while($orient)
 {
-  if(!system("exiftran -h >/dev/null 2>&1")) {
-    $exiftrancmd = "exiftran -aip";
-  } elsif(!system("exifautotran >/dev/null 2>&1")) {
-    $exiftrancmd = "exifautotran";
-  } else {
-    fatal("cannot execute exiftran or exifautotran for lossless JPEG autorotation");
-  }
+  $exiftrancmd = "exiftran -aip" if cmd_exists('exiftran');
+  last if $exiftrancmd;
+  $exiftrancmd = "exifautotran" if cmd_exists('exifautotran');
+  fatal 'Missing exiftran or exifautotran executable for JPEG autorotation'
+    unless $exiftrancmd;
 }
 
 # list available files
@@ -496,7 +501,7 @@ sub analyze_file
 
   my $props = ImageInfo($file, {PrintConv => 0, Sort => 'File'});
   unless(defined($props) && isin($props->{FileType}, @filetypes)) {
-    return undef;
+    return;
   }
 
   # sanitize file name
@@ -635,22 +640,24 @@ sub process_img
 
   # copy source file
   sys('cp', '-L', $file, $fout);
-  chmod(0600, $fout);
 
   # apply lossless transforms
-  if($orient && $props{FileType} eq "JPEG" && ($props{'Orientation'} // 0))
+  if(!$keeporig)
   {
-    sys("$exiftrancmd $fout 2>/dev/null");
-    if(($props{'Orientation'} // 0) > 4) {
-      ($props{ImageWidth}, $props{ImageHeight}) = ($props{ImageHeight}, $props{ImageWidth});
+    if($orient && $props{FileType} eq "JPEG" && ($props{'Orientation'} // 0))
+    {
+      sys("$exiftrancmd $fout 2>/dev/null");
+      if(($props{'Orientation'} // 0) > 4) {
+        ($props{ImageWidth}, $props{ImageHeight}) = ($props{ImageHeight}, $props{ImageWidth});
+      }
+    }
+    if($jpegoptim && $props{FileType} eq "JPEG") {
+      sys('jpegoptim', '-q', $fout);
+    } elsif($pngoptim && $props{FileType} eq "PNG")
+    {
+      sys('pngcrush', '-q', $fout, $ftmp);
+      rename($ftmp, $fout);
     }
-  }
-  if($jpegoptim && $props{FileType} eq "JPEG") {
-    sys('jpegoptim', '-q', $fout);
-  } elsif($pngoptim && $props{FileType} eq "PNG")
-  {
-    sys('pngcrush', '-q', $fout, $ftmp);
-    rename($ftmp, $fout);
   }
 
   # final file mode
@@ -658,11 +665,12 @@ sub process_img
   sys('touch', '-r', $file, $fout);
 
   # intermediate sRGB colorspace conversion
-  if(!$sRGB || ($props{ColorSpace} // 65535) == 1 || !defined($props{ProfileID})) {
-    link($fout, $ftmp) or sys('cp', '-L', $fout, $ftmp);
+  if(!$sRGB || !defined($props{ProfileID}) || ($props{ColorSpace} // 65535) == 1
+  || ($props{DeviceModel} // '') eq 'sRGB') {
+    $ftmp = $fout;
   } else
   {
-    sys('convert', $fout, '-compress', 'LZW', "tiff:$ftmp");
+    sys('convert', '-quiet', $fout, '-compress', 'LZW', '-type', 'truecolor', "tiff:$ftmp");
     sys($tificccmd, '-t0', $ftmp, "$ftmp.tmp");
     rename("$ftmp.tmp", $ftmp);
   }
@@ -674,7 +682,7 @@ sub process_img
 
   # generate main image
   my @sfile = ($props{ImageWidth}, $props{ImageHeight});
-  my @simg = sys('convert', $ftmp,
+  my @simg = sys('convert', '-quiet', $ftmp,
 		 '-gamma', '0.454545',
 		 '-geometry', "$maxfull[0]x$maxfull[1]>",
 		 '-print', '%w\n%h',
@@ -710,7 +718,7 @@ sub process_img
   my $dy = $sthumb[1] - $mthumb[1];
   my $cy = clamp(0, $dy, int($center[1] * $sthumb[1] - $sthumb[1] / 2 + $dy / 2));
 
-  sys('convert', $ftmp,
+  sys('convert', '-quiet', $ftmp,
       '-gamma', '0.454545',
       '-resize', "$sthumb[0]x$sthumb[1]!",
       '-gravity', 'NorthWest',
@@ -720,7 +728,7 @@ sub process_img
       '-quality', $imgq, "$out/$fthumb");
 
   # blur
-  sys('convert', "$out/$fthumb",
+  sys('convert', '-quiet', "$out/$fthumb",
       '-virtual-pixel', 'Mirror',
       '-gaussian-blur', "0x$backblur",
       '-scale', "$backsize[0]x$backsize[1]",
@@ -747,7 +755,9 @@ sub process_img
   }
 
   # remove temporary files
-  unlink($ftmp);
+  if($ftmp ne $fout) {
+    unlink($ftmp);
+  }
 
   return \%fdata;
 }
@@ -851,7 +861,12 @@ my $fd;
 unless(open($fd, ">:raw", "$out/data.json")) {
   fatal("cannot write data file: $!");
 }
-print($fd encode_json(\%json));
+print($fd JSON::PP->new->ascii->pretty->canonical->allow_blessed->encode(\%json));
 close($fd);
 
-print("completed\n");
+if ($use_symlinks) {
+    chdir($out) || die "Failed to 'cd $out' for symlink creation";
+    symlink(catfile('view', $_), '.') for ('index.html', '%%FG_VIEWDIR%%');
+}
+
+print("$0 $VERSION done\n");
